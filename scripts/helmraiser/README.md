# Helmraiser

Proof of concept for generating a Jsonnet library from any Helm chart. The goal is to keep track of upstream changes in
a Helm chart while retaining our Jsonnet changes (read: mixins) on top of them. This generated Jsonnet lib is intended
for internal use.

Essentially the script renders a Helm chart's manifests with `helm template` and imports them with
`std.native('parseYaml')`. It provides a structure to ease the maintenance burden and a basic lib that should cover for
the some common use cases.

To be clear, this is a simple tool that by no means intends to convert Helm charts and make them available to the
general public. It doesn't keep track of `values.yaml`, it doesn't implement if/for loops that may exist in the
templates, it is not Helm for Jsonnet.

## Prerequisites

* Bash (also: awk, sed)
* Helm (v3+)
* Jsonnet

Optional: Tanka

## Usage

    helmraiser.sh <path to helm chart> <output dir> ['<helm_args>'] [overwrite]

## Example workflow

Find a chart that you want to use, for this PoC I've chosen
[jetstack/cert-manager](https://hub.helm.sh/charts/jetstack/cert-manager) as we already converted it manually and we can
use Tanka to compare the outcome to the state in the cluster.

Ensure you have added the Helm repo:

    helm repo add jetstack https://charts.jetstack.io

Execute Helmraiser, the 3rd argument (if not 'overwrite') is passed to `helm template`:

    ./helmraiser.sh jetstack/cert-manager lib/cert-manager --version=v0.13.0

This gives us this nice directory structure:

    $ tree lib/cert-manager
    lib/cert-manager
    ├── generated.libsonnet
    ├── main.libsonnet
    ├── templated.libsonnet
    └── templates
        ├── cainjector-deployment.yaml
        ├── cainjector-rbac.yaml
        ├── cainjector-serviceaccount.yaml
        ├── deployment.yaml
        ├── rbac.yaml
        ├── serviceaccount.yaml
        ├── service.yaml
        ├── webhook-deployment.yaml
        ├── webhook-mutating-webhook.yaml
        ├── webhook-rbac.yaml
        ├── webhook-serviceaccount.yaml
        ├── webhook-service.yaml
        └── webhook-validating-webhook.yaml

The top level has 3 files and 1 directory:

* `generated.libsonnet`: Imports the yaml files from `templates/` into the Jsonnet scope
* `main.libsonnet`: Here you can start adding changes on top of the generated Jsonnet
* `templated.libsonnet`: A set of functions that are applied in `generated.libsonnet`
* `templates/`: The templates generated by `helm template`

After this, it is intended to modify the library to make it more usable, `main.libsonnet` will not be generated again on
upgrade. For this PoC, I changed the labels in main and added the CRDs and ClusterIssuers from the previous version
of this library.

    $ tree ksonnet/lib/cert-manager/
    ksonnet/lib/cert-manager/
    ├── cert-manager.libsonnet
    ├── config.libsonnet
    ├── crds.libsonnet
    ├── default_clusterissuers.libsonnet
    ├── files
    │   └── 00-crds.yaml
    ├── generated.libsonnet
    ├── main.libsonnet
    ├── templated.libsonnet
    └── templates/
        └── <truncated>

As per usual, rendering can be done with `tk eval`, `tk show` and eventually tested against Kubernetes
with `tk diff`. 

To update the rendered templates, run helmraiser again with the new version tag. This time add the 'overwrite' flag to
replace the existing generated `templates/` and `generated.libsonnet`:

    ./helmraiser.sh jetstack/cert-manager lib/cert-manager --version=v0.16.0 overwrite

Again, rendering can be done with Tanka. Depending on the modifications, changes between the 2 versions should only
reflect upstream changes with `tk diff`.

## Afterthoughts

* Helmraiser's arguments could be tracked in a file to reflect the state of the generated content.
* With the argument passed to `helm template`, it is possible to provide a `values.yaml`, might be useful for more
    elaborate libraries where a different base is preferred.
* Replacing existing resources in a cluster should do verification with `tk prune` too.
